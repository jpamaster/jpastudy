# jpa 기본편

## 영속성 컨텍스트

### 영속성 컨텍스트란?

- **엔티티를 영구 저장하는 환경**이라는 뜻입니다.
- 논리적인 개념으로서 엔티티 매니저를 통해서 영속성 컨텍스트에 접근입니다.

### 엔티티의 생명주기

- 비영속(new/transient)
    - 엔티티가 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태입니다.
- 영속(managed)
    - 엔티티가 영속성 컨텍스트에서 관리되는 상태입니다.
- 준영속(detached)
    - 영속성 컨텍스트에 저장되었다가 분리된 상태입니다.
- 삭제(remove)
    - 영속성 컨텍스트에서 삭제된 상태입니다.

### 비영속 상태

```kotlin
val member = Member(
             id = 1L,
             name = "뚜한"
         )
```

- 객체를 새롭게 생성한 상태입니다.
- 영속성 컨텍스트에서 관리하지 않기 때문에 더티채킹이나, 1차캐싱등을 이용할 수 없습니다.

### 영속 상태

```kotlin
fun main(args: Array<String>) {
    runApplication<Ex1HelloJpaKotlinApplication>(*args)
    val emf = Persistence.createEntityManagerFactory("hello")
    val em = emf.createEntityManager()
    val tx = em.transaction

    tx.begin()

    try {
         val member = Member(
             id = 1L,
             name = "뚜한"
         )
        em.persist(member)
        tx.commit()
    } catch (e: Exception) {
        tx.rollback()
    } finally {
        em.close()
    }
    emf.close()
}
```

### 1차 캐시란?

- persist(): 저장 , find(): 조회 를 하게되면 영속성컨텍스트의 1차 캐시에서 엔티티를 관리하게 됩니다(영속상태)
- 이 때 persist()를 한 엔티티와 같은 엔티티를 조회하게 된다면 데이터베이스에 조회쿼리를 날리지 않고 1차 캐시에 저장된 해당 엔티티를 반환하게 됩니다 → 조회쿼리를 날리지 않아 성능이점이 존재
- find()를 하는 순간 1차 캐시에 저장이 됩니다. 이 후 마찬가지로 해당 엔티티를 또 find()한다면 조회 쿼리를 날리지 않고 1차 캐시에서 해당 엔티티를 찾게 됩니다. → 이 후 더티체킹과도 관련 존재
- 영속성 컨텍스트에서 관리하는 엔티티는 동일성이 보장되어 한 트랜잭션 내에서 조회하는 같은 키값의 엔티티는 언제든 조회해도 동일한 엔티티입니다.

### 쓰기 지연이란?

- persist()를 하게 되면 1차 캐시에도 저장되지만 INSERT SQL을 데이터베이스에 전송하지 않고 쓰기지연 SQL 저장소에 INSERT 쿼리를 저장합니다.
- 이 후 커밋하는 순간 (커밋 바로 직전 자동으로 **flush() 가 동작하는데 이 때 쿼리가 날라갑니다.**)쿼리가 전송되고 커밋됩니다.

### 더티 체킹이란?

- 엔티티를 조회하게되면 (em.find()) 영속성 컨텍스트의 1차 캐시에 엔티티가 저장됩니다. 이 때 스냅샷을 찍어 **최초 상태**의 엔티티를 기록합니다.
- 이 후 엔티티의 상태를 변경한 후 (setter, ..) **트랜잭션 커밋을 하게된다면 실제로 직전에 flush()가 동작하는데 이 직전에** 1)해당 엔티티의 스냅샷과 현재 엔티티를 비교합니다.
- 2) 변경사항이 존재한다면 UPDATE SQL을 쓰기지연 저장소에 저장합니다.
- 3) 이 후 flush()를 통해 UPDATE 쿼리가 날라갑니다.
- 4) 마지막으로 트랜잭션이 커밋됩니다.
- 이 상황에선 persist()를 하지 않아도 됩니다. 이미 영속성 컨텍스트에서 저장이 되고 계속해서 엔티티의 변경을 감지하기 때문입니다.

### 플러시란?

- 쓰기 지연 저장소에 있는 SQL을 실제 데이터베이스에 보내는 과정입니다.
- 다시 말해, 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것입니다.
- 영속성 컨텍스트를 비우는 것이 아닙니다.
- 트랜잭션이라는 작업단위가 중요하기 때문에 커밋 직전에만 동기화하면 됩니다.

### 영속성 컨텍스트를 플러시하는 방법은?

- em.flush() 를 직접 호출합니다.
- 트랜잭션을 커밋합니다. → 자동 호출
- JQPL 쿼리를 실행합니다. → 자동 호출

### 준영속 상태

```kotlin
em.detach(member.javaClass, 1L)
em.clear()
em.close()
```

- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리되는 것입니다.
- 영속성 컨텍스트가 제공하는 기능을 사용하지 못합니다.
- 준영속 상태로 만드는 방법은 위 코드와 같습니다.